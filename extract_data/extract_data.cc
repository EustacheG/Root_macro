#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <vector>
#include <unistd.h>
#include <fstream>
#include <sstream>
#include <math.h>
#include <stdlib.h>     /* system, NULL, EXIT_FAILURE */

#include "TFile.h"
#include "TH3.h"
#include "TSystem.h"
#include "TTree.h"
#include "TTreeReader.h"
#include "TNtuple.h"

using namespace std;

int main(int argc, char** argv)
{

    //Extract data of a root file generated by bdsim (can go in rebdsim).
    // 1: input.root
    // 2: output.root


    bool extract_by_name; // default value
    bool extract_all;
    string element_name;
    double xmin, xmax, ymin, ymax, zmin, zmax;

    cout << argc << endl;
    switch (argc) {
        case 3:
        {
          extract_all = true;
          extract_by_name = !(extract_all);
          cout << "Extract all values" << endl;
	  break;
        }
        case 4:
        {
            extract_all = false;
	        extract_by_name = !(extract_all);
            element_name = (string) argv[3];
            cout << "Extract using extract_by_name: not yet implemented" << endl;
            //return -1;
            break;
        }


        case 9:
        {
            extract_by_name = false;
            xmin = atof(argv[3]);
            xmax = atof(argv[4]);
            ymin = atof(argv[5]);
            ymax = atof(argv[6]);
            zmin = atof(argv[7]);
            zmax = atof(argv[8]);
            cout << "Extract using extract_by_position" << endl;
        }
            break;

        default:
        {
            cerr << "Error : no enough arguments" << endl;
            return -1;
        }
    }

    TString input_filename = argv[1];
    TString output_filename = argv[2];

    cout << "Load rebdsim librairies " << endl;
    gSystem->Load("librebdsim.so");
    gSystem->Load("libbdsimRootEvent");

    /// Open the root tree
    TFile *input_file = 0;
    cout << "Open file" << endl;
    input_file = new TFile(input_filename);

    cout << "Get the tree" << endl;
    TTreeReader reader("Event", input_file);

    // Get the desired data (correspond to selection in analysisConfig.txt)
    TTreeReaderValue<vector<Float_t>> elossX(reader, "Eloss.X");
    TTreeReaderValue<vector<Float_t>> elossY(reader, "Eloss.Y");
    TTreeReaderValue<vector<Float_t>> elossZ(reader, "Eloss.Z");
    TTreeReaderValue<vector<Float_t>> elossEne(reader, "Eloss.preStepKineticEnergy");
    TTreeReaderValue<vector<Float_t>> elossStepLength(reader, "Eloss.stepLength");
    TTreeReaderValue<vector<Float_t>> elossWeight(reader, "Eloss.weight");
    TTreeReaderValue<vector<string>> elossVolName(reader, "Eloss.volName");
    TTreeReaderValue<vector<int>> elossParentID(reader, "Eloss.partID");
    TTree *tree = (TTree*)input_file->Get("Event"); // initialising the TREE
    int nevents = (Int_t)tree->GetEntries();

    /// Create a file for saving ntuples
    TFile* output_file = 0;
    output_file = new TFile(output_filename,"recreate");
    TNtuple *ntuple = new TNtuple("Data","Data","X:Y:Z:E:L:PartId:Weight");

    /// Treat the files
    Int_t current_evt=0;

    while (reader.Next())
    {
        vector<Float_t> data_elossX = *elossX;
        vector<Float_t> data_elossY = *elossY;
        vector<Float_t> data_elossZ = *elossZ;
        vector<Float_t> data_elossEne = *elossEne;
        vector<Float_t> data_elossStL = *elossStepLength;
        vector<Float_t> data_elossWeight = *elossWeight;
        vector<string> data_elossVolName = *elossVolName;
        vector<int> data_elossPartID = *elossParentID;

        int size = data_elossX.size();
        for (unsigned int i =0; i < size; i++)
        {
            /// Extract data
            double xpos = data_elossX[i];
            double ypos = data_elossY[i];
            double zpos = data_elossZ[i];
            double energy = data_elossEne[i]*1000; // in MeV
            double steplength = data_elossStL[i]*100; // in cm
            int particle_Id = data_elossPartID[i];
            double weight = data_elossWeight[i];
            string volName = data_elossVolName[i];

            //TODO : best way to fill the ntuple
            if(extract_by_name)
            {
                string bdsim_element_name = element_name;
                if (volName != "World")
                {
                    bdsim_element_name = "world_PREPEND"+element_name+"boxPhysical_pv"; // temporaire ?
                }
                //TODO: see if it is still possible.
                if(volName == bdsim_element_name)
                {
                    ntuple->Fill(xpos,ypos,zpos,energy,steplength,particle_Id, weight);
                }
            }
            else if(extract_all)
            {
                ntuple->Fill(xpos,ypos,zpos,energy,steplength,particle_Id, weight);
            }
            else
            {
                /// Fill the ntuple
                if(xpos > xmin && xpos < xmax && ypos > ymin && ypos < ymax && zpos > zmin && zpos < zmax)
                {
                    ntuple->Fill(xpos,ypos,zpos,energy,steplength,particle_Id, weight);
                }
            }
        }
        if(current_evt % (nevents/10) == 0)
        {
            cout <<"Begin treatment of event #" << current_evt << " over " << nevents << endl;
        }
        current_evt++;
    }

    /// Save the TNuples
    output_file->Write();

    delete ntuple;
    cout << "Finish" <<endl;

    return 0;
}
